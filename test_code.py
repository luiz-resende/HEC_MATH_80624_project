"""
Tests for the code files.
"""

import numpy as np
from oracle import Oracle
from uncertainty import BudgetUncertaintySet, CertaintySet, EllipsoidalUncertaintySet
from tool import maxGrad, gradient
from dualsubgradient import dualSubgradient


def test_oracle():
    r"""
    Function asserts the result from ``oracle()``.

    Returns
    -------
    None.
    """
    abar = np.array([0.20000, 0.18750, 0.16250, 0.15000], dtype=float)
    n = len(abar)
    cs = (30.0 * np.ones(n, dtype=float))
    ds = (1000.0 * np.ones(n, dtype=float))
    ps = (0.10 * np.array([1.100, 0.850, 0.900, 0.800], dtype=float))
    B = 1.0
    eps = 0.0001

    abar = abar * (1.0 - np.array([0.05390, 0.74720, 0.02590, 0.17300], dtype=float))

    fval, x = Oracle(eps, abar, cs, ds, ps, B).solve(False)
    # print(fval, x)

    expect_fval = 0.05261329356026702
    expect_x = np.array([0.017715505600, 0.000479657947, 11.086796900000, 0.002083670990], dtype=float)

    assert np.round(fval, 4) == np.round(expect_fval, 4)
    assert np.array_equal(np.round(x, 3), np.round(expect_x, 3))


def test_ellipsoidal_set():
    r"""
    Function asserts the results generated by ``EllipsoidalUncertaintySet()``.

    Returns
    -------
    None.
    """
    size = 2
    rho = 1.0
    store = 10
    Z_set = EllipsoidalUncertaintySet(size=size, rho=rho, n_store=store)

    is_feasible = []
    diam = []
    z0_1 = Z_set.store[0]
    for i, _ in enumerate(range(store)):
        z = Z_set.get()
        is_feasible.append(int(Z_set.feasible(z)))
        diam.append(np.linalg.norm(z, 2))
        # print(f"{z} is inside the set: {bool(is_feasible[i])},  diameter: {diam[i]}")
    assert (np.sum(is_feasible, dtype=int) == store)
    assert (np.all(np.array(diam, dtype=float) <= 1.0))

    z0_2 = Z_set.get()
    assert (not np.array_equal(z0_1, z0_2))

    z0 = Z_set.get()
    z = Z_set.project(z0)
    # print(f"z0: {z0}, projected z: {z}")

    z0 = np.array([2.0, 3.0])
    z = Z_set.project(z0)
    assert (np.linalg.norm(z, 2) == 1.0)
    # print(f"z0: {z0}, projected z: {z}")
    # print(f"|z0|: {np.linalg.norm(z0, 2)}, |z|: {np.linalg.norm(z, 2)}")


def test_budgeted_set():
    r"""
    Function asserts the results generated by ``BudgetUncertaintySet()``.

    Returns
    -------
    None.
    """
    size = 10
    Gamma = 2.0
    store = 10
    Z_set = BudgetUncertaintySet(size=size, Gamma=Gamma, half=True, n_store=store)

    assert (np.round(Z_set.diam(), 9) == 2.0)

    # check realizations
    z0_1 = Z_set.store[0]
    for _ in range(50):
        z = Z_set.get()
        # print(z)
    assert (not np.array_equal(z0_1, Z_set.store[0]))

    # print("diameter:", Z_set.diam())  # Check diameter

    # z0 is outside uncertainty set
    z0 = np.ones(size)
    z = Z_set.project(z0)
    assert (Z_set.feasible(z))
    # print("z is feasible:", Z_set.feasbile(z))
    # print(z, np.linalg.norm(z - z0, 2))

    # z0 is inside
    z0 = np.zeros(size)
    z = Z_set.project(z0)
    assert (Z_set.feasible(z))
    # print("z is feasible:", Z_set.feasbile(z))
    # print(z, np.linalg.norm(z - z0, 2))

    # z0 is inside
    z0 = Z_set.get()
    z = Z_set.project(z0)
    assert (Z_set.feasible(z))
    # print("z is feasible:", Z_set.feasbile(z))
    # print(z, np.linalg.norm(z - z0, 2))


def test_maxGrad():
    r"""
    Function asserts the results generated by ``maxGrad()``.

    Returns
    -------
    None.
    """
    size = 4
    abar = np.array([0.20000, 0.18750, 0.16250, 0.15000], dtype=float)
    cs = (30.0 * np.ones(size))
    ds = (1000.0 * np.ones(size))
    ps = (0.1 * np.array([1.100, 0.850, 0.900, 0.800], dtype=float))
    B = 1.0

    # maxg = maxGrad(abar, cs, ds, ps, B)
    # print(maxg)

    assert(np.round(maxGrad(abar, cs, ds, ps, B), 3) == np.round(0.373339345092314, 3))


def test_gradient():
    r"""
    Function asserts the results generated by ``gradient()``.

    Returns
    -------
    None.
    """
    size = 4
    abar = np.array([0.20000, 0.18750, 0.16250, 0.15000], dtype=float)
    cs = (30.0 * np.ones(size))
    ds = (1000.0 * np.ones(size))
    xs = np.ones(size, dtype=float)

    expected = np.array([0.029991, 0.02999063, 0.02998988, 0.02998951], dtype=float)

    assert(np.array_equal(np.round(gradient(abar, cs, ds, xs), 3), np.round(expected, 3)))


def test_dual_sub_grad():
    r"""
    Function asserts the results generated by ``dualSubgradient()``.

    Returns
    -------
    None.
    """
    size = 4
    abar = np.array([0.20000, 0.18750, 0.16250, 0.15000], dtype=float)
    cs = (30.0 * np.ones(size))
    ds = (1000.0 * np.ones(size))
    ps = (0.1 * np.array([1.100, 0.850, 0.900, 0.800], dtype=float))
    B = 1.0
    Gamma = 1.0
    eps = 1e-6

    U = BudgetUncertaintySet(size, Gamma, half=True)

    fval, x = dualSubgradient(eps, U, abar, cs, ds, ps, B, display=True, earlystop=False, itermax=200)
    print(fval, np.round(x, 4))
